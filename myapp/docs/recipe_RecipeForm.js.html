<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: recipe/RecipeForm.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: recipe/RecipeForm.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Button, Form} from 'react-bootstrap'
import {useState, useEffect, useCallback, useRef} from "react";
import IngredientInputs from "./IngredientInputs";
import CategoryRadioButtons from "./CategoryRadioButtons";
import RecipeDetailsModal from "./RecipeDetailsModal";

/**
 * @module
 * Component used to render a UI to create a recipe via the form tag
 * @returns {JSX.Element} the JSX code to render to the DOM tree
 * @constructor
 */
export default function RecipeForm() {
    /**
     * the object to store the values of name, description, and source for the recipe and the state updater function
     * @constant
     *
     * @type {object}
     * @type {function}
     */
    const [recipeFields, setRecipeFields] = useState({
        formRecipeName: "", formRecipeDesc: "", formRecipeSource: ""
    });

    /**
     * the object to store the error messages for the following recipe fields: name, description, and source and the state updater function
     * @constant
     *
     * @type {object}
     * @type {function}
     */
    const [recipeErrors, setRecipeErrors] = useState({});

    /**
     * the array to store ingredients and the state updater function
     * @constant
     *
     * @type {array}
     * @type {function}
     */
    const [ingredients, setIngredients] = useState([
        {formIngredientName: "", formIngredientAmount: ""},
        {formIngredientName: "", formIngredientAmount: ""},
    ]);

    /**
     * the array to store error messages for ingredients and the state updater function
     * @constant
     *
     * @type {array}
     * @type {function}
     */
    const [ingredientsErrors, setIngredientsErrors] = useState([
        {}, {}
    ]);

    /**
     * the object to reference the form tag
     * @constant
     *
     * @type {object}
     */
    const recipeForm = useRef(null);

    /**
     * the boolean to set the visibility of the modal which contains the details of the recipe and the state updater function
     * @constant
     *
     * @type {boolean}
     * @type {function}
     */
    const [recipeDetailsVisible, setRecipeDetailsVisible] = useState(false);

    /**
     * the array that stores valid values for the source input
     * @constant
     *
     * @type {array}
     */
    const validSources = [
        "cookbook",
        "cooking magazine",
        "website",
        "family",
        "newspaper",
        "friend"
    ]

    /**
     * the boolean to track whether the radio button for category is checked and its state updater function
     * @constant
     *
     * @type {boolean}
     * @type {function}
     */
    const [categoryChecked, setCategoryChecked] = useState(false);

    /**
     * the string to store the value of the selected radio button for category and its state updater function
     * @constant
     *
     * @type {string}
     * @type {function}
     */
    const [categoryVal, setCategoryVal ] = useState(null);

    /**
     * The function first trims all the values of the entries stored in ingredients and returns them in currentIngredients.
     * It also returns ingredientsFieldsValid, with which the result of the validation can be quickly accessed.
     * It also returns currentIngredientsErrors to store individual error message for each set of ingredient fields.
     * All the returned values are stored inside an object and returned as an object.
     *
     * @type {object}
     */
    const handleIngredientsFieldsValidation = useCallback(() => {
        let currentIngredients = [];
        let currentIngredientsErrors = [];
        let ingredientsFieldsValid = true;

        // Iterate each ingredient
        ingredients.forEach((ingredient, idx) => {
            const trimmedFields = {};
            const currentErrors = {};

            // Trim each field in the ingredient
            Object.keys(ingredient).map(key => trimmedFields[key] =
                ingredient[key].trim());

            let key = "formIngredientName";
            let field = trimmedFields[key];
            if (field.length === 0) {
                currentErrors[key] = "Name is required";
                ingredientsFieldsValid = false;
            } else if (field.length > 20) {
                currentErrors[key] = "Name of ingredient can contain a maximum of 20 characters";
                ingredientsFieldsValid = false;
            }

            key = "formIngredientAmount";
            field = trimmedFields[key];
            if  (field.length === 0) {
                currentErrors[key] = "Amount is required";
                ingredientsFieldsValid = false;
            } else if (!/^-*\d+$/.test(field)) {
                currentErrors[key] = "Amount should contain only digits";
                ingredientsFieldsValid = false;
            } else if (Number(field) &lt;= 0) {
                currentErrors[key] = "Amount should contain a positive number";
                ingredientsFieldsValid = false;
            }

            currentIngredientsErrors.push(currentErrors);
            currentIngredients.push(trimmedFields);
        })

        return {currentIngredients, ingredientsFieldsValid, currentIngredientsErrors};
    }, [ingredients]);

    // Add an event listener for an enter key. When the enter key is pressed, validate all the ingredient fields
    // and then create another row for an additional ingredient if the fields are validated. Otherwise, display error messages if needed.
    useEffect(() => {
        /**
         * When the enter key is pressed, validate all the ingredient fields
         * and then create another row for an additional ingredient if the fields are validated. Otherwise, display error messages if needed.
         *
         * @param event
         *
         * @returns {function} a callback function to remove the event listener
         */
        const keyDownHandler = event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                const { currentIngredientsErrors} = handleIngredientsFieldsValidation();

                let isFilled = true;
                currentIngredientsErrors.forEach(entry => {
                    for (const [key, value] of Object.entries(entry)) {
                        if (value.includes("required")) {
                            isFilled = false;
                        }
                    }
                })

                if (isFilled) {
                    setIngredients([...ingredients, {formIngredientName: "", formIngredientAmount: ""}])
                    setIngredientsErrors([...ingredientsErrors, {}])
                } else {
                    setIngredientsErrors([...currentIngredientsErrors]);
                }
            }
        };

        document.addEventListener('keydown', keyDownHandler);

        return () => {
            document.removeEventListener('keydown', keyDownHandler);
        }
    }, [handleIngredientsFieldsValidation, ingredientsErrors, ingredients])

    /**
     * When the user types in any of the following fields: name, description, and source,
     * the corresponding state variable is updated with the value typed.
     * @param e the triggered event
     *
     * @returns void
     */
    const handleRecipeInputChange = (e) => {
        setRecipeFields({...recipeFields, [e.target.name]: e.target.value})
    }

    /**
     * The function validates all the required fields in the form. If not valid, display error messages
     * set in handleValidation. Otherwise, save the recipe details in localStoage and make visible the modal
     * that contains the recipe details as well as an image of the recipe fetched from Unsplash.
     * @param e triggered event
     *
     * @returns void
     */
    const handleSubmit = (e) => {
        e.preventDefault();
        const {trimmedFields, currentIngredients, isValid } = handleValidation();

        if (!isValid)
            return;

        localStorage.setItem("name", recipeFields['formRecipeName']);
        localStorage.setItem("desc", recipeFields['formRecipeDesc']);
        localStorage.setItem("source", recipeFields['formRecipeSource']);
        localStorage.setItem("category", categoryVal);
        localStorage.setItem("ingredients", JSON.stringify(ingredients));

        setRecipeDetailsVisible(true);
    }

    /**
     * A callback function passed to the recipe details modal to call when the user clicks
     * the close button, upon which the form and the states are reset.
     *
     * @returns void
     */
    const hideModalHandler = () => {
        recipeForm.current.reset();
        setRecipeFields({formRecipeName: "", formRecipeDesc: "", formRecipeSource: ""});
        setIngredients([
            {formIngredientName: "", formIngredientAmount: ""},
            {formIngredientName: "", formIngredientAmount: ""},
        ])
        setIngredientsErrors([{},{}]);
        setRecipeDetailsVisible(false);
    }

    /**
     * The function first trims all the values of the following fields: name, description, and source
     * and then returns the trimmed values in trimmedRecipeFields.
     * It also returns currentRecipeErrors that contain an error message for each field if any.
     *
     * @returns {{currentRecipeErrors: {}, trimmedRecipeFields: {}}}
     */
    const handleRecipeFieldsValidation = () => {
        const trimmedRecipeFields = trimRecipeFields();
        const currentRecipeErrors = {};

        let key = "formRecipeName";
        let field = trimmedRecipeFields[key];
        if (field.length === 0) {
            currentRecipeErrors[key] = "Recipe name is required.";
        }

        key = "formRecipeDesc";
        field = trimmedRecipeFields[key];
        if (field.length === 0) {
            currentRecipeErrors[key] = "Description is required.";
        } else if (field.length > 100) {
            currentRecipeErrors[key] = "Description can contain a maximum of 100 characters.";
        }

        key = "formRecipeSource";
        field = trimmedRecipeFields[key];
        if (field.length === 0) {
            currentRecipeErrors[key] = "Source is required.";
        } else if (!validSources.includes(field.toLowerCase())) {
            currentRecipeErrors[key] = "Source should be any one of the values: cookbook, cooking magazine, website, family, newspaper, or friend"
        }

        key = "formRecipeCategory";
        if (!categoryChecked) {
            currentRecipeErrors[key] = "Category needs to be checked";
        }

        return {trimmedRecipeFields, currentRecipeErrors}
    }

    /**
     * The callback function is called from the component IngredientInputs to remove an ingredient row.
     * @param idx the index for the ingredient to be deleted in the array ingredients
     */
    const deleteIngredient = (idx) => {
        let tempIngredients = ingredients;
        let tempIngredientsErrors = ingredientsErrors;
        tempIngredients.splice(idx, 1);
        tempIngredientsErrors.splice(idx, 1);
        setIngredients([...tempIngredients]);
        setIngredientsErrors([...tempIngredientsErrors]);
    }

    /**
     * handleValidation calls handleRecipeFieldsValidation for the following fields: name, description, and source.
     * It also calls handleIngredientsFieldsValidation to validate each row representing an ingredient.
     *
     * @returns {object}
     */
    const handleValidation = () => {
        const {trimmedRecipeFields, currentRecipeErrors} = handleRecipeFieldsValidation();
        setRecipeErrors(currentRecipeErrors);

        const {currentIngredients, ingredientsFieldsValid, currentIngredientsErrors} = handleIngredientsFieldsValidation();
        setIngredientsErrors([...currentIngredientsErrors]);
        setIngredients([...currentIngredients]);

        return {trimmedRecipeFields, currentIngredients,
                isValid: Object.keys(currentRecipeErrors).length === 0 &amp;&amp; ingredientsFieldsValid};
    }

    /**
     * The function trims potential whitespace found in the values typed by the user
     *
     * @returns {{}} an object that contains the trimmed values from recipeFields
     */
    const trimRecipeFields = () => {
        const trimmedFields = {};
        Object.keys(recipeFields).map(key => trimmedFields[key] = recipeFields[key].trim());
        setRecipeFields(trimmedFields);
        return trimmedFields;
    }

    return (
        &lt;>
            &lt;Form onSubmit={handleSubmit} ref={recipeForm}>
                {/*Name*/}
                &lt;Form.Group className="mb-3"
                            aria-labelledby="formRecipeNameLabel"
                            controlId="formRecipeName"
                >
                    &lt;Form.Label id="formRecipeNameLabel">Name&lt;/Form.Label>
                    &lt;Form.Control type="text"
                                  name="formRecipeName"
                                  aria-required="true"
                                  value={recipeFields.formRecipeName}
                                  onChange={handleRecipeInputChange}
                                  isInvalid={recipeErrors.hasOwnProperty("formRecipeName")}/>
                    &lt;Form.Control.Feedback type="invalid">
                        {recipeErrors.formRecipeName}
                    &lt;/Form.Control.Feedback>
                &lt;/Form.Group>

                {/*Description*/}
                &lt;Form.Group className="mb-3"
                            aria-labelledby="formRecipeDescLabel"
                            controlId="formRecipeDesc"
                >
                    &lt;Form.Label id="formRecipeDescLabel">Description&lt;/Form.Label>
                    &lt;Form.Control type="text"
                                  name="formRecipeDesc"
                                  aria-required="true"
                                  value={recipeFields.formRecipeDesc}
                                  onChange={handleRecipeInputChange}
                                  isInvalid={recipeErrors.hasOwnProperty("formRecipeDesc")}/>
                    &lt;Form.Control.Feedback type="invalid">
                        {recipeErrors.formRecipeDesc}
                    &lt;/Form.Control.Feedback>
                &lt;/Form.Group>

                {/*Source*/}
                &lt;Form.Group className="mb-3"
                            aria-labelledby="formRecipeSourceLabel"
                            controlId="formRecipeSource"
                >
                    &lt;Form.Label id="formRecipeSourceLabel">Source&lt;/Form.Label>

                    &lt;Form.Control type="text"
                                  name="formRecipeSource"
                                  aria-required="true"
                                  value={recipeFields.formRecipeSource}
                                  onChange={handleRecipeInputChange}
                                  isInvalid={recipeErrors.hasOwnProperty("formRecipeSource")}/>
                    &lt;Form.Control.Feedback type="invalid">
                        {recipeErrors.formRecipeSource}
                    &lt;/Form.Control.Feedback>
                    &lt;Form.Text>Type any one of the values: cookbook, cooking magazine, website, family, newspaper, or friend&lt;/Form.Text>
                &lt;/Form.Group>

                {/*Category*/}
                &lt;Form.Group className="mb-3"
                            aria-labelledby="formRecipeCategoryLabel"
                >
                    &lt;span id="formRecipeCategoryLabel" className="d-block mb-2">Category&lt;/span>
                    &lt;CategoryRadioButtons setCategoryChecked={setCategoryChecked}
                                          setCategoryVal={setCategoryVal}
                                          isInvalid={recipeErrors.hasOwnProperty("formRecipeCategory")}/>

                &lt;/Form.Group>

                {/*Ingredients*/}
                &lt;div className="mb-3"
                     aria-labelledby="formRecipeIngredients"
                >
                    {/*Use span instead of label when there is no corresponding input tag*/}
                    &lt;span id="formRecipeIngredients" className="d-block">Ingredients&lt;/span>
                    &lt;small className="mb-2">Fill all the fields below and enter to add another ingredient&lt;/small>
                    {ingredients.map((ingredient, idx) =>
                        &lt;IngredientInputs key={idx}
                                          idx={idx}
                                          ingredients={ingredients}
                                          setIngredients={setIngredients}
                                          ingredientsErrors={ingredientsErrors}
                                          deleteIngredient={deleteIngredient}/>)}
                &lt;/div>
                &lt;Button variant="success" type="submit">Submit&lt;/Button>
            &lt;/Form>

            {/*Modal*/}
            {recipeDetailsVisible &amp;&amp; (
                &lt;RecipeDetailsModal recipeDetailsVisible={recipeDetailsVisible}
                                    hideModalHandler={hideModalHandler}
                                    recipeFields={recipeFields}
                                    categoryVal={categoryVal}
                                    ingredients={ingredients}/>
            )}
        &lt;/>
    );


}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Component%2520used%2520to%2520render%2520a%2520UI%2520to%2520create%2520a%2520recipe%2520via%2520the%2520form%2520tag.html">Component used to render a UI to create a recipe via the form tag</a></li><li><a href="module.html#.exports">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#App">App</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Mon Oct 31 2022 21:01:39 GMT+1100 (Australian Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
